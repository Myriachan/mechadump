#include "common.hpp"

#include <cstring>
#include <libcdvd.h>
#include <unistd.h>

#include "configexploit.hpp"

// OpenConfig params:
//   0 = must be 00 or 01; becomes bit 1 of config_open_status
//   1 = written to config_open_status+1
//   2 = written to config_open_status+3, and times 16 to config_write_size
// config_open_status+1 selects:
//   0 = config_write_buffer1, offset 0x270
//   1 = config_write_buffer2, offset 0x2B0
//   2 = config_write_buffer3, offset 0x200
//
// ReadConfig:
//   no params
//   reads 16 bytes at config_write_address + value of config_open_status+2
//   subtracts 1 from config_open_status+3
//   adds 16 then mods by 256 to config_open_status+2

enum ConfigBlockID : uint8_t
{
	CONFIG_BLOCK_270 = 0x00,
	CONFIG_BLOCK_2B0 = 0x01,
	CONFIG_BLOCK_200 = 0x02,
};

struct ConfigBlockEntry
{
	ConfigBlockID m_blockID;
	unsigned m_eepromByteAddress;
	size_t m_size;
	size_t m_configInfoOffset;
};
const ConfigBlockEntry s_configBlocks[] =
{
	{ CONFIG_BLOCK_270, 0x270, sizeof(ConfigInfo::m_config270), offsetof(ConfigInfo, m_config270) },
	{ CONFIG_BLOCK_2B0, 0x2B0, sizeof(ConfigInfo::m_config2B0), offsetof(ConfigInfo, m_config2B0) },
	{ CONFIG_BLOCK_200, 0x200, sizeof(ConfigInfo::m_config200), offsetof(ConfigInfo, m_config200) },
};

// Read EEPROM at a given arbitrary offset.
// The offset is given in bytes, though note that the EEPROM device is
// natively addressed in 16-bit words.
bool ReadNVM(uint8_t* output, unsigned offset, unsigned length)
{
	uint8_t result[3];

	if (offset >= 0x400)
		return false;
	if (0x400 - offset < length)
		return false;

	// ReadNVM takes a big-endian EEPROM offset and returns a big-endian uint16,
	// unlike everything else in PS2 and Mechacon.

	// If offset is odd, even it out.
	if (offset % 2)
	{
		uint8_t wordOffset[2] =
		{
			static_cast<uint8_t>((offset / 2) >> 8),
			static_cast<uint8_t>(offset / 2)
		};
		if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
			return false;
		if (result[0] != 0x00)
			return false;
		
		*output++ = result[1];
		++offset;
		--length;
	}
	
	// Read words.
	while (length >= 2)
	{
		uint8_t wordOffset[2] =
		{
			static_cast<uint8_t>((offset / 2) >> 8),
			static_cast<uint8_t>(offset / 2)
		};
		if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
			return false;
		if (result[0] != 0x00)
			return false;
		
		*output++ = result[2];
		*output++ = result[1];
		offset += 2;
		length -= 2;
	}
	
	// If there's one byte remaining, handle it.
	if (length > 0)
	{
		uint8_t wordOffset[2] =
		{
			static_cast<uint8_t>((offset / 2) >> 8),
			static_cast<uint8_t>(offset / 2)
		};
		if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
			return false;
		if (result[0] != 0x00)
			return false;
		
		*output++ = result[2];
		++offset;
		--length;
	}
	
	return true;
}

// Calls OpenConfig with the specified parameters.
bool OpenConfig(bool forWriting, uint8_t whichBlock, uint8_t rowCount)
{
	uint8_t request[3] =
	{
		static_cast<uint8_t>(forWriting),
		whichBlock,
		rowCount
	};
	uint8_t reply[1];
	
	if (!sceCdApplySCmd(0x40, request, sizeof(request), reply, sizeof(reply)))
		return false;
	
	return reply[0] == 0x00;
}

// Reads rowCount * 16 bytes to output.
bool ReadConfig(uint8_t* output, uint8_t rowCount)
{
	for (unsigned row = 0; row < rowCount; ++row)
	{
		uint8_t reply[0x10];
		if (!sceCdApplySCmd(0x41, nullptr, 0, reply, sizeof(reply)))
			return false;

		std::memcpy(&output[row * 0x10], reply, 0x10);
	}
	
	return true;
}

// Do the WriteConfig command to write to EEPROM.
bool WriteConfig(const uint8_t* data, uint8_t rowCount)
{
	for (unsigned row = 0; row < rowCount; ++row)
	{
		uint8_t reply[1];
		if (!sceCdApplySCmd(0x42, &data[row * 0x10], 0x10, reply, sizeof(reply)))
			return false;
		
		if (reply[0] != 0x00)
			return false;
	}
	
	return true;
}

uint8_t CloseConfigInternal()
{
	uint8_t reply[1];
	if (!sceCdApplySCmd(0x43, nullptr, 0, reply, sizeof(reply)))
		return false;

	return reply[0];
}

bool CloseConfigAndWait()
{
	for (;;)
	{
		uint8_t result = CloseConfigInternal();
		if (result == 0x00)  // success
			return true;
		else if (result == 0x01)  // EEPROM operations not finished
			continue;
		else  // some error (config never opened?)
			return false;
	}
}

// Is this 16-byte row valid for WriteConfig?
bool IsValidConfigRowChecksum(const uint8_t* row)
{
	unsigned sum = 0;
	for (int i = 0; i < 15; ++i)
		sum += row[i];
	return row[15] == static_cast<uint8_t>(sum);
}

// Fixes the checksum byte after the 15 data bytes of the row.
void FixConfigRowChecksum(uint8_t* row)
{
	unsigned sum = 0;
	for (int i = 0; i < 15; ++i)
		sum += row[i];
	row[15] = static_cast<uint8_t>(sum);
}

bool ConfigInfo::HasValidChecksums() const
{
	const unsigned char* infoBytes = reinterpret_cast<const unsigned char*>(this);

	for (const ConfigBlockEntry& block : s_configBlocks)
	{
		for (unsigned x = 0; x < block.m_size; x += 0x10)
		{
			if (!IsValidConfigRowChecksum(infoBytes + x))
				return false;
		}
	}
	
	return true;
}

// Read the standard config blocks (EEPROM 0x200-0x31F).
bool ReadAllConfig(ConfigInfo& info)
{
	unsigned char* infoBytes = reinterpret_cast<unsigned char*>(&info);

	for (const ConfigBlockEntry& block : s_configBlocks)
	{
		if (!OpenConfig(false, block.m_blockID, block.m_size / 0x10))
			return false;
		if (!ReadConfig(infoBytes + block.m_configInfoOffset, block.m_size / 0x10))
			return false;
		if (!CloseConfigAndWait())
			return false;
	}
	
	return true;
}

// Write the standard config blocks (EEPROM 0x200-0x31F).
bool WriteAllConfig(const ConfigInfo& info)
{
	const unsigned char* infoBytes = reinterpret_cast<const unsigned char*>(&info);

	for (const ConfigBlockEntry& block : s_configBlocks)
	{
		if (!OpenConfig(true, block.m_blockID, block.m_size / 0x10))
			return false;
		if (!WriteConfig(infoBytes + block.m_configInfoOffset, block.m_size / 0x10))
			return false;
		if (!CloseConfigAndWait())
			return false;
	}
	
	return true;
}

bool WriteConfigExploit(const uint8_t* patchData, int& errorCode)
{
	errorCode = 0;
	
	// Dump the existing config blocks for restoration.
	ConfigInfo configBackup;
	if (!ReadAllConfig(configBackup))
	{
		errorCode = 1;
		return false;
	}
	
	// Weird stuff will happen if any rows' checksums are bad.
	if (!configBackup.HasValidChecksums())
	{
		errorCode = 2;
		return false;
	}
	
	// Both the WriteConfig SCMD handler and the underlying code to write to
	// EEPROM wrap around the buffer after 0x100 bytes because they store the
	// index as uint8.  But we can still ask it to write up to 0x1F0, which
	// it will do.  This will trash config memory, but we just saved it!
	//
	// Do the exploit by wrapping the 0x270 buffer around.
	// Using the 0x270 buffer means that there is 0x70+0x40+0x70 = 0x120
	// bytes of memory to hit our target without corrupting critical
	// structures that happen to be right after the third buffer.  We only
	// need 0x100...
	//
	// The simplest way to do this write is to just imagine that we're
	// writing 0x400 - 0x270 = 0x190 bytes.  The wrapping buffer just means
	// that copies of the patch data end up where config used to be.
	if (!OpenConfig(true, CONFIG_BLOCK_270, 0x190 / 0x10))
	{
		errorCode = 3;
		return false;
	}
	
	// Write zero rows until it's time to send patch data.
	uint8_t zeros[0x10]{};
	for (int i = 0; i < 0x190 - 0xE0; i += 0x10)
	{
		if (!WriteConfig(zeros, 1))
		{
			// Attempt to restore config.
			CloseConfigAndWait();
			WriteAllConfig(configBackup);

			errorCode = 4;
			return false;
		}
	}
	
	// Write the 0xE0 bytes of patch data.  However, hold off on the last
	// row for a safety check.
	if (!WriteConfig(patchData, 0xD0 / 0x10))
	{
		// Attempt to restore config.
		CloseConfigAndWait();
		WriteAllConfig(configBackup);

		errorCode = 5;
		return false;
	}
	
	// Write the final row.
	if (!WriteConfig(patchData + 0xD0, 0x10 / 0x10))
	{
		// Attempt to restore config.
		CloseConfigAndWait();
		WriteAllConfig(configBackup);

		errorCode = 6;
		return false;
	}

	// Need to make sure write finishes...

	sleep(2);
	
	CloseConfigAndWait();
	
	// The write succeeded.  Return true no matter what now, but set
	// error code if restoring config fails.
	if (!WriteAllConfig(configBackup))
	{
		errorCode = 7;
		return true;
	}

	uint8_t checkPatchset[0xE0];
	if (!ReadNVM(checkPatchset, 0x320, 0xE0))
	{
		errorCode = 8;
		return false;
	}
	
	if (std::memcmp(checkPatchset, patchData, 0xE0) != 0)
	{
		errorCode = 9;
		return false;
	}
	
	return true;
}
